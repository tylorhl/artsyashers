@using System.Collections.Generic
@using Tylorhl.ArtsyAshers.Svg
@using Newtonsoft.Json
@inject HttpClient Http
@inject IJSRuntime JsRuntime

<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="2.0" class="container" x="0px" y="0px" viewBox="0 0 1000 1000">
    <defs>
        @foreach (var path in SelectedPaths)
        {
            <path d="@(path.Data.ToString())" id="path@(path.Id)" class="pathcomponent" />
        }
        @if(CombinedPath != null)
        {
            <path d="@(CombinedPath.Data.ToString())" id="combinedpath"/>
        }
    </defs>
    @if(CombinedPath != null)
    {
        <g class="group">
        @for (int i = 0; i < PixelCount; i++)
        {
            string fill = i == 0 ? "#FF0000" : "#FFFFFF";
            <circle cx="5" cy="5" r="8" fill="@fill" id="p@(i)" class="hidden">
                @{
                    string beginvis = i != 0 ? $"p{i-1}vis.end" : "0s";
                    double nextBegin = 0;
                }
                @if(i!=0)
                {
                <animate attributeType="XML" attributeName="class" from="hidden" to="visible" begin="@(beginvis)" dur="@(PixelDistance)s" id="p@(i)vis" fill="freeze" values="hidden ; visible" keyTimes="0 ; 1"/>
                }

                <animateMotion dur="@(CombinedPath.Duration)s" begin="@(PixelDistance*i)s" repeatCount="indefinite" id="runningAnimation" keyPoints="@KeyPoints" keyTimes="@KeyTimes" calcMode="linear">
                            <mpath href="#combinedpath"></mpath>
                    </animateMotion>
            </circle>
        }
    </g>
    }
    
    
</svg>

@code {
    private static List<Path> Paths;

    [Parameter] private int? Seed {get;set;}
    [Parameter] private uint PixelCount {get;set;} = 45;
    [Parameter] private uint PathCount {get;set;} = 5;
    [Parameter] private int Loops {get;set;} = 2;
    [Parameter] private double Dur {get;set;} = 5.0;
    [Parameter] private double PixelDistance {get;set;} = 0.1; // Likely to change
    private Path CombinedPath = null;
    private string KeyPoints;
    private string KeyTimes;

    public List<Path> SelectedPaths {get; private set;} = new List<Path>();

    protected override async Task OnInitAsync()
    {
        if(Paths == null)
        {
            var pathsDict = await Http.GetJsonAsync<Dictionary<string,string>>("./paths.json");
            Paths = pathsDict.Select(kvp => new Path(kvp.Value){ Id = kvp.Key, Duration = Dur }).ToList();
        }

        SelectedPaths = Paths.ToList();

        Shuffle(SelectedPaths);

        SelectedPaths = SelectedPaths.Take((int)PathCount).ToList();

        // Add transitions
        for(int i = 0; i < SelectedPaths.Count - 1; i += 2)
        {
            var current = SelectedPaths[i];
            var next = SelectedPaths[i+1];

            var newPath = new Path()
            {
                Data = next.Data - current.Data,
                Transitonary = true,
                Id = $"{current.Id}{next.Id}",
                Duration = Dur/8
            };

            SelectedPaths.Insert(i+1, newPath);
        }

        SelectedPaths.Add(new Path()
            {
                Data = SelectedPaths.First().Data - SelectedPaths.Last().Data,
                Transitonary = true,
                Id = $"{SelectedPaths.First().Id}{SelectedPaths.Last().Id}",
                Duration = Dur/8
            });

        CombinedPath = Path.Concat(SelectedPaths.ToArray());
    }

    private void Shuffle(IList<Path> paths)
    {
        Random rand = null;

        if(Seed != null)
            rand = new Random((int)Seed);
        else
            rand = new Random();

        int n = paths.Count;  
        while (n > 1) {  
            n--;  
            int k = rand.Next(n + 1);  
            var value = paths[k];  
            paths[k] = paths[n];  
            paths[n] = value;  
        } 
    }

    protected override async Task OnAfterRenderAsync()
    {
        if(KeyPoints != null)
        return;

        var points = await JsRuntime.InvokeAsync<double[]>("GetPathLengths", null);
        if(points == null || points.Length == 0)
            return;
            
        double totalDistance = points.Sum();
        double currentDistance = 0;
        double currentDur = 0;

        KeyPoints = "0;" + string.Join(";", points.Select(p => (currentDistance += (p/totalDistance))));
        KeyTimes = "0;" + string.Join(";", SelectedPaths.Select(p => currentDur += p.Duration/CombinedPath.Duration));

        System.Diagnostics.Debug.WriteLine($"KeyPoints set: {KeyPoints}");
        System.Diagnostics.Debug.WriteLine($"KeyTimes set: {KeyTimes}");
        System.Diagnostics.Debug.WriteLine($"CombinedPath.Duration set: {CombinedPath.Duration}");

        this.StateHasChanged();
    }
}